# Решение конфликта слияния в supabase_api.py

## Что произошло

При попытке подтянуть изменения возник конфликт слияния, потому что у вас была своя версия файла `supabase_api.py`, которая отличается от измененной версии.

## Решение конфликта

### Вариант 1: Использовать версию с исправлениями (рекомендуется)

Если вы хотите использовать версию с исправлениями разлогинивания:

1. **В VS Code откройте файл `supabase_api.py`**

2. **Найдите маркеры конфликта** (они выглядят так):
   ```
   <<<<<<< HEAD
   (ваш код)
   =======
   (код с исправлениями)
   >>>>>>> cursor/are-you-there-3152
   ```

3. **Выберите вариант с исправлениями**:
   - В VS Code нажмите на кнопку **"Accept Incoming Change"** (принять входящие изменения)
   - Или вручную удалите маркеры конфликта и оставьте код между `=======` и `>>>>>>>`

4. **Сохраните файл** (Ctrl+S)

5. **Завершите merge**:
   ```bash
   git add supabase_api.py
   git commit -m "Разрешен конфликт: принята версия с исправлениями разлогинивания"
   ```

### Вариант 2: Вручную добавить методы

Если вы хотите сохранить свою версию, но добавить исправления:

1. **Откройте файл `supabase_api.py` в VS Code**

2. **Найдите место после метода `get_active_sessions()`** (примерно строка 195)

3. **Добавьте следующие методы** (скопируйте из раздела ниже)

4. **Сохраните файл и завершите merge**:
   ```bash
   git add supabase_api.py
   git commit -m "Разрешен конфликт: добавлены методы разлогинивания"
   ```

## Методы, которые нужно добавить

Добавьте эти методы в класс `SupabaseAPI` после метода `get_active_sessions()`:

```python
    def get_all_active_sessions(self) -> List[Dict]:
        """Получить все активные сессии (совместимость с sheets_api)"""
        return self.get_active_sessions()
    
    def check_user_session_status(self, email: str, session_id: str) -> str:
        """
        Проверяет статус указанной сессии пользователя в Supabase.
        Возвращает: 'active', 'kicked', 'finished', 'expired', 'unknown'
        """
        try:
            email_lower = (email or "").strip().lower()
            session_id_str = str(session_id).strip()
            
            # Ищем сессию по email и session_id
            response = self.client.table('active_sessions')\
                .select('status')\
                .eq('email', email_lower)\
                .eq('session_id', session_id_str)\
                .order('login_time', desc=True)\
                .limit(1)\
                .execute()
            
            if response.data:
                status = (response.data[0].get('status') or '').strip().lower()
                return status if status else 'unknown'
            
            # Если точного совпадения нет, ищем по email (последняя сессия)
            response = self.client.table('active_sessions')\
                .select('status')\
                .eq('email', email_lower)\
                .order('login_time', desc=True)\
                .limit(1)\
                .execute()
            
            if response.data:
                status = (response.data[0].get('status') or '').strip().lower()
                return status if status else 'unknown'
            
            return 'unknown'
            
        except Exception as e:
            logger.error(f"Failed to check session status for {email}: {e}")
            return 'unknown'
    
    def kick_active_session(
        self,
        email: str,
        session_id: Optional[str] = None,
        status: str = "kicked",
        remote_cmd: str = "FORCE_LOGOUT",
        logout_time: Optional[Any] = None
    ) -> bool:
        """
        Принудительно завершает ПОСЛЕДНЮЮ активную сессию пользователя.
        """
        try:
            email_lower = (email or "").strip().lower()
            
            # Обрабатываем logout_time: может быть datetime, строка или None
            if logout_time is None:
                logout_time_str = datetime.now(timezone.utc).isoformat()
            elif isinstance(logout_time, datetime):
                logout_time_str = logout_time.isoformat()
            else:
                logout_time_str = str(logout_time)
            
            # Формируем данные для обновления
            update_data = {
                'status': status,
                'logout_time': logout_time_str,
                'remote_command': remote_cmd,
                'updated_at': datetime.now(timezone.utc).isoformat()
            }
            
            # Ищем активные сессии пользователя
            query = self.client.table('active_sessions')\
                .select('*')\
                .eq('email', email_lower)\
                .eq('status', 'active')
            
            # Если указан session_id, фильтруем по нему
            if session_id:
                query = query.eq('session_id', str(session_id).strip())
            
            response = query.order('login_time', desc=True).execute()
            
            if not response.data:
                logger.info(f"No active session found for {email}")
                return False
            
            # Берем последнюю активную сессию
            session = response.data[0]
            session_id_to_update = session.get('session_id')
            
            # Обновляем сессию
            self.client.table('active_sessions')\
                .update(update_data)\
                .eq('session_id', session_id_to_update)\
                .execute()
            
            logger.info(f"Successfully kicked session {session_id_to_update} for {email}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to kick active session for {email}: {e}", exc_info=True)
            return False
    
    def finish_active_session(
        self,
        email: str,
        session_id: str,
        logout_time: Optional[str] = None,
        reason: str = "user_exit"
    ) -> bool:
        """
        Завершает активную сессию пользователя (Status=finished).
        """
        try:
            email_lower = (email or "").strip().lower()
            session_id_str = str(session_id).strip()
            logout_time_str = logout_time or datetime.now(timezone.utc).isoformat()
            
            update_data = {
                'status': 'finished',
                'logout_time': logout_time_str,
                'logout_reason': reason,
                'updated_at': datetime.now(timezone.utc).isoformat()
            }
            
            response = self.client.table('active_sessions')\
                .update(update_data)\
                .eq('email', email_lower)\
                .eq('session_id', session_id_str)\
                .eq('status', 'active')\
                .execute()
            
            if response.data:
                logger.info(f"Successfully finished session {session_id_str} for {email}")
                return True
            else:
                logger.info(f"No active session found with session_id {session_id_str} for {email}")
                return False
                
        except Exception as e:
            logger.error(f"Failed to finish active session for {email}: {e}", exc_info=True)
            return False
    
    def ack_remote_command(self, email: str, session_id: str) -> bool:
        """
        Отправляет подтверждение получения удаленной команды.
        """
        try:
            email_lower = (email or "").strip().lower()
            session_id_str = str(session_id).strip()
            
            update_data = {
                'remote_command': '',  # Очищаем команду после подтверждения
                'updated_at': datetime.now(timezone.utc).isoformat()
            }
            
            self.client.table('active_sessions')\
                .update(update_data)\
                .eq('email', email_lower)\
                .eq('session_id', session_id_str)\
                .execute()
            
            logger.debug(f"ACK sent for remote command: {email}, session_id={session_id_str}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to ACK remote command for {email}: {e}")
            return False
    
    def set_active_session(
        self,
        email: str,
        name: str,
        session_id: str,
        login_time: Optional[str] = None
    ) -> bool:
        """
        Создает или обновляет активную сессию пользователя.
        """
        try:
            email_lower = (email or "").strip().lower()
            login_time_str = login_time or datetime.now(timezone.utc).isoformat()
            
            # Получаем user_id
            user_response = self.client.table('users')\
                .select('id')\
                .eq('email', email_lower)\
                .execute()
            
            user_id = user_response.data[0]['id'] if user_response.data else None
            
            data = {
                'session_id': session_id,
                'email': email_lower,
                'name': name,
                'user_id': user_id,
                'login_time': login_time_str,
                'status': 'active',
                'created_at': datetime.now(timezone.utc).isoformat(),
                'updated_at': datetime.now(timezone.utc).isoformat()
            }
            
            # Проверяем, существует ли уже сессия с таким session_id
            existing = self.client.table('active_sessions')\
                .select('id')\
                .eq('session_id', session_id)\
                .execute()
            
            if existing.data:
                # Обновляем существующую сессию
                self.client.table('active_sessions')\
                    .update(data)\
                    .eq('session_id', session_id)\
                    .execute()
            else:
                # Создаем новую сессию
                self.client.table('active_sessions').insert(data).execute()
            
            logger.info(f"Active session set for {email}, session_id={session_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to set active session for {email}: {e}", exc_info=True)
            return False
    
    # Дополнительные методы для совместимости
    def get_user_by_email(self, email: str) -> Optional[Dict[str, str]]:
        """Получить пользователя по email"""
        try:
            email_lower = (email or "").strip().lower()
            response = self.client.table('users')\
                .select('*')\
                .eq('email', email_lower)\
                .execute()
            
            if response.data:
                row = response.data[0]
                return {
                    'Email': row.get('email', ''),
                    'Name': row.get('name', ''),
                    'Phone': row.get('phone', ''),
                    'Role': row.get('role', ''),
                    'Telegram': row.get('telegram_id', ''),
                    'Group': row.get('group_name', ''),
                    'NotifyTelegram': 'Yes' if row.get('notify_telegram') else 'No'
                }
            return None
            
        except Exception as e:
            logger.error(f"Failed to get user by email {email}: {e}")
            return None
    
    def delete_user(self, email: str) -> bool:
        """Удалить пользователя (пометить как неактивного)"""
        try:
            email_lower = (email or "").strip().lower()
            self.client.table('users')\
                .update({'is_active': False, 'updated_at': datetime.now(timezone.utc).isoformat()})\
                .eq('email', email_lower)\
                .execute()
            logger.info(f"User {email} marked as inactive")
            return True
        except Exception as e:
            logger.error(f"Failed to delete user {email}: {e}")
            return False
    
    def update_user_fields(self, email: str, fields: Dict[str, str]) -> None:
        """Обновить поля пользователя"""
        try:
            email_lower = (email or "").strip().lower()
            
            # Преобразуем поля из формата Sheets в формат Supabase
            data = {}
            field_mapping = {
                'Name': 'name',
                'Phone': 'phone',
                'Role': 'role',
                'Telegram': 'telegram_id',
                'Group': 'group_name',
                'NotifyTelegram': 'notify_telegram'
            }
            
            for key, value in fields.items():
                if key in field_mapping:
                    db_key = field_mapping[key]
                    if db_key == 'notify_telegram':
                        data[db_key] = str(value).lower() in ('yes', 'true', '1', 'да')
                    else:
                        data[db_key] = value
            
            data['updated_at'] = datetime.now(timezone.utc).isoformat()
            
            self.client.table('users')\
                .update(data)\
                .eq('email', email_lower)\
                .execute()
            
            logger.info(f"Updated fields for user {email}")
            
        except Exception as e:
            logger.error(f"Failed to update user fields for {email}: {e}")
            raise
    
    def log_user_actions(self, actions: List[Dict[str, Any]], email: str, user_group: Optional[str] = None) -> bool:
        """
        Записать действия пользователя в лог.
        """
        try:
            if not actions:
                return True
            
            # Получаем user_id
            user = self.get_user_by_email(email)
            if not user:
                logger.warning(f"User {email} not found, cannot log actions")
                return False
            
            user_response = self.client.table('users')\
                .select('id')\
                .eq('email', email.lower())\
                .execute()
            
            user_id = user_response.data[0]['id'] if user_response.data else None
            
            # Подготавливаем данные для вставки
            records = []
            for action in actions:
                record = {
                    'user_id': user_id,
                    'email': email.lower(),
                    'name': action.get('name', ''),
                    'timestamp': action.get('timestamp') or datetime.now(timezone.utc).isoformat(),
                    'action_type': action.get('action_type', ''),
                    'status': action.get('status', ''),
                    'comment': action.get('comment', ''),
                    'session_id': action.get('session_id', ''),
                    'status_start_time': action.get('status_start_time'),
                    'status_end_time': action.get('status_end_time'),
                    'reason': action.get('reason'),
                    'user_group': user_group or action.get('user_group')
                }
                records.append(record)
            
            # Вставляем записи batch-ом
            self.client.table('work_log').insert(records).execute()
            
            logger.info(f"Logged {len(records)} actions for {email}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to log user actions for {email}: {e}", exc_info=True)
            return False
```

## Быстрое решение в VS Code

1. **Откройте файл `supabase_api.py`**
2. **Нажмите Ctrl+Shift+P** (Command Palette)
3. **Введите "Git: Resolve Conflicts"** или **"Accept All Incoming"**
4. **Выберите "Accept All Incoming Changes"** (принять все входящие изменения)
5. **Сохраните файл** (Ctrl+S)
6. **Завершите merge**:
   ```bash
   git add supabase_api.py
   git commit -m "Разрешен конфликт: принята версия с исправлениями"
   ```

## Проверка после разрешения конфликта

Убедитесь, что методы добавлены:

```bash
grep -n "def kick_active_session" supabase_api.py
grep -n "def check_user_session_status" supabase_api.py
grep -n "def finish_active_session" supabase_api.py
```

Должны увидеть номера строк с определениями методов.
