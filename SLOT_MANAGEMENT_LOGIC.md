# Логика работы со слотами в шаблонах перерывов

## Общая концепция

В Supabase шаблоны перерывов хранятся в таблице `break_schedules` следующим образом:

1. **Основная запись шаблона** - одна запись с `name`, `shift_start`, `shift_end`, `is_active=True`, и **пустым `description`** (или `NULL`)
2. **Записи слотов** - отдельные записи для каждого слота с тем же `name`, но с **JSON в `description`**, содержащим:
   - `slot_type` - тип слота ("Перерыв" или "Обед")
   - `duration` - длительность в минутах
   - `window_start` - начало окна времени
   - `window_end` - конец окна времени
   - `priority` - приоритет/порядок

## Структура данных

### В диалоге (`BreakScheduleDialog`)
Слоты представлены как список словарей:
```python
slots_data = [
    {
        "order": "1",
        "type": "Перерыв",  # Ключ: "type"
        "duration": "15",
        "window_start": "10:00",
        "window_end": "12:00"
    },
    {
        "order": "2",
        "type": "Обед",  # Ключ: "type"
        "duration": "60",
        "window_start": "12:00",
        "window_end": "14:00"
    }
]
```

### При сохранении в БД
Каждый слот сохраняется как отдельная запись в `break_schedules`:
- `name` = имя шаблона (одинаковое для всех записей шаблона)
- `description` = JSON строка с данными слота
- `shift_start`, `shift_end` = время смены (копируется из основной записи)

### При чтении из БД
1. Группируем записи по `name`
2. Запись с пустым `description` = основная запись шаблона (используем для `shift_start`, `shift_end`)
3. Записи с JSON в `description` = слоты (парсим JSON и извлекаем данные)

## Процесс создания шаблона

1. **Первый слот:**
   - Создается основная запись (без `description`)
   - Создается запись слота (с JSON в `description`)

2. **Последующие слоты:**
   - Основная запись уже существует, пропускаем её создание
   - Создаем только запись слота (с JSON в `description`)

## Процесс обновления шаблона

1. **Удаление старого шаблона:**
   - Удаляем ВСЕ записи с таким `name` (и основную, и все слоты)
   - Удаляем связанные назначения (`user_break_assignments`)

2. **Создание нового шаблона:**
   - Создаем новую основную запись
   - Создаем записи для всех слотов

## Процесс чтения шаблона (`list_schedules`)

1. Читаем все записи из `break_schedules`
2. Группируем по `name`
3. Для каждой группы:
   - Находим основную запись (без `description`)
   - Извлекаем `shift_start`, `shift_end` из основной записи
   - Для всех остальных записей (с `description`):
     - Парсим JSON из `description`
     - Извлекаем данные слота
     - Добавляем в `slots_data`

## Исправленные проблемы

### Проблема 1: Неправильный ключ для типа слота
**Было:** `slot.get('slot_type')`  
**Стало:** `slot.get('type') or slot.get('slot_type')`  
**Причина:** В диалоге используется ключ `'type'`, а не `'slot_type'`

### Проблема 2: Удаление только одной записи вместо всех
**Было:** Удаление по `id` (только одна запись)  
**Стало:** Удаление по `name` (все записи шаблона)  
**Причина:** В Supabase шаблоны группируются по `name`, а не по `schedule_id`

### Проблема 3: Дублирование основной записи
**Было:** Основная запись создавалась для каждого слота  
**Стало:** Основная запись создается только один раз при первом слоте  
**Причина:** Проверка существования основной записи перед созданием

## Тестирование

Используйте скрипт `test_slot_management.py` для проверки:
1. Создание шаблона с одним слотом
2. Добавление второго слота (обновление)
3. Удаление слота (обновление с меньшим количеством слотов)

```bash
python test_slot_management.py
```
